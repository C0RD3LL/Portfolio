---
title: "RNA-Seq Analysis"
author: "Cordell Browne"
date: "cordell@knights.ucf.edu"
output:
  html_document:
    toc: yes
    toc_float: yes
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**My Machine:** 
(1) MacBook Pro (16-inch, 2021), Apple M1 Pro, 16 GB memory.(2) Google Cloud Platform  VM instance, 16 vcpu, 64 GB memory.





## Abstract

High-throughput sequencing techniques such as RNA-Sequencing (RNA-Seq) have become a de facto method for initiating transcriptomic research. Advances in RNA-Seq processes have allowed researchers to gain insight with Omics data in ways that were not feasible before. The focus of this document is to illustrate an  end-to-end workflow on bulk RNA-Seq data, covering topics like exploratory data analysis, differential expression, and co-expression analysis ultimately to gain beneficial knowledge of the data from the statistical methods applied to it.

## Introduction
_**(Preprocessing)**_

While the focus is essentially a RNA-Seq pipeline analysis, the purpose of this document is to show competency with RNA-Seq related software and an ability to interpret data provided by said software/tools.


**About the data:**

The data was selected via  GEO browser, so no analytical insight was provided outside of the following information. 

- 9 oral squamous cell carcinoma (OSCC) samples were obtained, 5 with lymph node metastasis (LNM) and 4 without LNM. 

- Once the tumor samples were collected from host they were put on ice, then treated with a trizol reagent to extract RNA. The RNA was than sequenced (paired-end reads) using a standard illumina protocol.

- The lab that published the samples data state that when comparing the differentially expressed genes between OSCC, samples with LNM and those without were determined that immune response is an important factor in OSCC LNM, also using qRT-PCR candidate genes involved in anti tumor immunity were confirmed. 

- ( _Disadvantages:_ small sample size not good =( ) 

_Reference_: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE176221



**Get Fastq Reads** 

In order to retrieve from SRA, sratools command, `fasterqdump`  was used to loop through and download all study samples. 
```{bash}
#for ((i = 26; i <= 34; i++))
#  do
#  fasterq-dump SRR147406$i
#done
```

**Quality control on reads** 

FastQC + MultiQC confirmed that fastq files were trimmed  before SRA submission.

**Preparing Count Matrix**

The data needs to be processed in a way so it can provide insight to the statistical characteristics of the biological samples. In order to do so, the fastq files were converted into a count matrix. To start a reference genome must be generated then the reads must be aligned to said reference genome to determine the abundances of count per transcript. 

**Generate reference genome** 
```{bash}
#STAR --runThreadN 16 \
#--runMode genomeGenerate \
#--genomeDir ref \
#--genomeFastaFiles ref/GRCh38.primary_assembly.genome.fa \
#--sjdbGTFile ref/gencode.v39.annotation.gtf 
```

**Align Samples to reference** 
```{bash}
#for file in *1.fastq; do name=$(basename ${file} 1.fastq)

#  STAR --runMode alignReads --genomeDir ../index/ \
#  --outSAMtype BAM SortedByCoordinate \ 
#  --readFilesIn ${name}1.fastq ${name}2.fastq \
#  --runThreadN 12 \
#  --outFileNamePrefix ../mapped/${name}
#;done
```

**BAMs to Count Matrix** 

Generating a count table with featureCounts. output ``count.out``
```{bash}
#featureCounts -a ref/gencode.v39.annotation.gtf -o count.out -T 8 -p bams/*.bam
```


**Transform count.out** 

The featureCounts output must be edited so it can be used by programs like DESeq2
```{r, message=FALSE}

library(readr)
library(tibble)
library(kableExtra) #Fancy tables 
library(ggplot2)
count <- read_table("../Downloads/count-2.out", col_names= FALSE,skip = 1)
kbl(head(count))  %>%
  kable_paper() %>%
  scroll_box(width = "100%", height = "200px")
```



Edit Data frame. 
```{r,warning=FALSE}
count <- count[,-c(2:6)] # Get rid of columns (2-6)
names(count) <- count[1,]; count <- count[-1,] #Row to columnnames
count[,2:10] <- sapply(count[, 2:10], as.numeric) #Change column type from char to numeric.
count <- column_to_rownames(count, var="Geneid")

#Sample names becomes columns. M for positive metastasis, NM for negative metastasis.
colnames(count) <-  c(
  "Sample_1_M","Sample_2_M","Sample_3_M",
  "Sample_4_NM","Sample_5_NM","Sample_6_NM",
  "Sample_7_M","Sample_8_M","Sample_9_NM"
)
```

```{r}
# filter rows with sums less than 25.
count <- count[which(rowSums(count) > 25),]

#Metadata
condition <- factor(c("M","M","M",
                      "NM","NM","NM",
                      "M","M","NM"))
coldata <- data.frame(row.names=  colnames(count), condition)
```

**Get Gene Symbols** 
```{r,message=FALSE,warning=FALSE}
library("AnnotationDbi")
library("org.Hs.eg.db")

#Get gene symbols
columns(org.Hs.eg.db)
geneSymbols <- mapIds(org.Hs.eg.db, keys=rownames(count), column="SYMBOL", keytype="ENSEMBL", multiVals="first")
geneSymbols <- as.data.frame(geneSymbols)
```


`


Completed Dataframe 
```{r}
kbl(head(count))  %>%
  kable_paper() %>%
  scroll_box(width = "100%", height = "200px")
```


`

`

```{r}
suppressMessages(library(DESeq2))
dds <- suppressMessages(DESeqDataSetFromMatrix(countData = count, colData = coldata, design = ~condition))
rld <-rlog(dds)
dds <- estimateSizeFactors(dds)
```

## Exploratory Data Analysis 

Once the count matrix is successfully generated the rest of the workflow can be sectioned into three distinct phase (highlighted in the table of contents) EDA, Differential Expression, and co-expression analysis. EDA is performed firstly to understand the makeup of our data, checking for inconsistency, noise and more.

  
Does normalization help adjust global differences between the samples? The influence of the sequencing depth normalization, can be seen in graphic below.
```{r,fig.width = 10, fig.height = 5}
par(mfrow=c(1,2))

SumNorm <- colSums(counts(dds, normalize= TRUE))
Sum <- colSums(counts(dds))

barplot(Sum,main = "Non-normalized read counts")
barplot(SumNorm,main = "Size-factor-normalized read counts")

```


```{r,fig.width = 10, fig.height = 5}
par(mfrow=c(1,2))

boxplot(log2(counts(dds)+1), 
        notch=TRUE, 
        main = "Non-normalized read counts", 
        ylab="log2(read counts)", cex = .6)

boxplot(log2(counts(dds, normalize= TRUE) +1), 
        notch=TRUE, 
        main = "Size-factor-normalized read counts", 
        ylab="log2(read counts)", cex = .6)
```


```{r}
dds <- suppressMessages(DESeq(dds))
res <- results(dds)
resDF <- as.data.frame(res)
vsdata <- vst(dds)
vassay <- assay(vsdata)
```

```{r}
#res to dataframe with gene symbols included
symbol_df <- merge(geneSymbols, resDF,
                          by = 'row.names', all = TRUE)
colnames(symbol_df)[1] <- "Gene_Ids"
symbol_df <- column_to_rownames(symbol_df, var="Gene_Ids")


```


```{r, fig.width= 10, fig.height= 5}
par(mfrow=c(1,3))

plot(log2(counts(dds)[,1:2] + 1),pch=16, cex=0.3,main="log")
rldassay <- assay(rld)
plot(rldassay[,1:2],pch=16, cex=0.3,main="rlog")
plot(vassay[,1:2],pch=16, cex=0.3,main="vst")
```
  
We can see how genes with low counts are excessively variable on the logarithmic scale and somewhat with variance stabilizing transformation (VST), while the rlog transform compresses variance of low count genes.The fanning out of the points in the lower left corner indicates that read counts correlate less well between replicates when they are low. This observation indicates that the standard deviation of the expression levels may depend on the mean: the lower the mean read counts per gene, the higher the standard deviation.


One thing to note from the three scatter plots above is VST (right) is shifted upwards about 5 square units. It isnt on the same scale as log 2 transformation(left) and rlog(middle) which are both roughly the same scaling.The deviation in y to x shown in the scatter plots contribute to the distance calculation that is used in principal component analysis.. 
 
  
.


**PCA** 

Sample-to-sample distances can be visualized via principal components analysis (PCA). Points(samples) are projected onto the 2D plane such that they spread out in the two directions that capture variance across samples. 

```{r,fig.width = 20, fig.height = 10,warning=FALSE}
suppressMessages(library(gridExtra))#Extensions to the grid system, with an emphasis on higher-level functions to work with grid graphic objects, rather than the lower-level utilities

rlpcadata <- plotPCA(rld, intgroup = "condition", returnData=TRUE)
pcadata <- plotPCA(vsdata, intgroup="condition", returnData=TRUE)

percentVar <- round(100 * attr(pcadata, "percentVar"))
percentVarr <- round(100 * attr(rlpcadata, "percentVar"))



p1 <- ggplot(pcadata, aes(PC1, PC2, color = condition)) + geom_point(size=3) +
  geom_text(label=rownames(pcadata),nudge_x = 2,nudge_y = -1)+
   geom_label(
    label=" VST PCA", 
    x=70,
    y=30,
    label.padding = unit(0.55, "lines"), # Rectangle size around label
    label.size = 0.35,
    color = "black",
    fill="#69b3a2"
  )+
  xlim(-80,80)+
  ylim(-60,33)+
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
   ylab(paste0("PC2: ",percentVar[2],"% variance"))

p2 <- ggplot(rlpcadata, aes(PC1, PC2, color = condition)) + geom_point(size=3) +
  geom_text(label=rownames(rlpcadata),nudge_x =-3,nudge_y = 2)+
  geom_label(
    label="Rlog PCA", 
    x=70,
    y=30,
    label.padding = unit(0.55, "lines"), # Rectangle size around label
    label.size = 0.35,
    color = "black",
    fill="#69b3a2"
  )+
  xlim(-80,80)+
  ylim(-60,33)+
  xlab(paste0("PC1: ",percentVarr[1],"% variance")) +
   ylab(paste0("PC2: ",percentVarr[2],"% variance"))

grid.arrange(p1,p2,nrow=1)
```

Rlog aims to reduce variability of low count genes and it can be seen in PCA that we lose variance compared to vst. The x-axis (PC1) separates the data points the most in both cases while the y-axis (PC2) separates it second most. If our data was ideal, the separation associated with PC1 would be  between the LMN(M) vs No-LNM(NM) and PC2 would separate samples in the group or vice versa. The data observed biologically makes sense because of the similarity in sample types and also because of small sample size.  Variance percentage is printed in the axis label; these percentages do not add to 100%, because there are more directions that contain the remaining variance.

_reference_:https://doi.org/10.1038/nmeth.4346



## Differential Expression
```{r}
dds <- suppressMessages(DESeq(dds))
```


**Gene Clustering** 


Heatmaps can be of great use in assessing differentially expressed genes and performing unsupervised clustering on the underlying data of the heatmap to determine sub-categories .The dendrogram at the top of our heatmaps shows a hierarchical clustering of the samples, and the one on the side is of the genes. Clustering is only relevant for genes that actually carry a signal. However, the  heatmap becomes more interesting if we don't focus on  absolute expression strength but rather at how much  each gene deviates in a specific sample from the gene’s average across all samples.


```{r,fig.width = 10, fig.height = 5,message=FALSE}
library("genefilter")
library("pheatmap")

DGE.results.sorted <- res[order(res$padj),]
DGEgenes <- rownames(subset(DGE.results.sorted, padj < .5)) #Set my pvalue high in order to get more data (to fit my bias)
rlog.dge <- dds[DGEgenes,] %>% assay
pheatmap(rlog.dge, scale="row", show_rownames = FALSE, main = " ")
```

```{r,fig.width = 10, fig.height = 5,message=FALSE}
DGEgenes <- rownames(subset(DGE.results.sorted, padj <= .05))
rlog.dge <- dds[DGEgenes,] %>% assay
pheatmap(rlog.dge, scale="row", show_rownames = FALSE, main = "(padj < .05)")
```


.


.


__View Statically Significant Data__
```{r}

# List of genes with lowest p-value 
list <- c("ENSG00000188856","ENSG00000156076", "ENSG00000185069",
          "ENSG00000259781", "ENSG00000185960" ,  "ENSG00000134240")

#plot 6 lowest p-values
par(mfrow=c(2,3))
for(i in list){
  plotCounts(dds, gene= i, intgroup="condition")
  }
```


```{r}
symbol_df <- symbol_df[order(symbol_df$padj),]
kbl(symbol_df[1:20,c(1,6:7)],caption = "20 Most Statistically Significant Expressed Genes") %>%
  kable_paper()
```

 
 
 
**MA Plot**  

An MA plot visualizes the differences between measurements taken in two samples by transforming data onto M(log ratio) and A (mean average), then plotting those values.The red points indicate genes for which the log2 fold change was significantly higher than 1 or less than -1  with padj less than 0.1. Blue indicates genes with  lower padj.To improve the fold change estimates for our data, we want to take our results and shrink the log2 fold changes using the lfcShrink() function. The shrunken log fold changes are useful for ranking and visualization, without the need for arbitrary filters on low count genes.  


In DESeq2 ,there are three adaptive shrinkage estimators, available via `lfcShrink`.


Shrinkage Estimators:

- `normal` original DESeq2 shrinkage estimator, an adaptive Normal distribution. (can sometimes produce too strong of shrinkage for certain datasets.)

- `apeglm` (Approximate Posterior Estimation for GLM) This is the suggested model because it  does a much better job at preserving signal while shrinking away noise than others. It's better both in ranking gene by effect size and in mean absolute error, comparing to the true LFC when it is known.

- `ashr`Implements an Empirical Bayes approach for large-scale hypothesis testing and false discovery rate (FDR) estimation based on the methods proposed in M. Stephens, 2016. 


```{r,fig.width = 10, fig.height = 6,message=FALSE,warning=FALSE}

resLFC <- lfcShrink(dds, coef="condition_NM_vs_M", type="apeglm")
resNorm <- lfcShrink(dds, coef=2, type="normal")
resAsh <- lfcShrink(dds, coef=2, type="ashr")

par(mfrow=c(1,3), mar=c(4,4,2,1))

plotMA(resLFC ,main="apeglm", colSig= "red")
plotMA(resNorm, main="normal", colSig= "red")
plotMA(resAsh,main="ashr", colSig= "red")
```


What you can see is that many genes are not significant even though they have large(r) FCs and a lot of the data seems to be very lowly-expressed (left side of the plot) even though there are significant genes with low(er) FCs that are significant. That could be indicative of quite some variability in at least one of the experimental groups. The plot below works on padj scale so there wont be a hard cut off soe we can observe data that is approaching 0.05.

```{r,fig.width = 15, fig.height = 8,message=FALSE}
library(scales) # needed for oob parameter
library(viridis)
resDF <- as.data.frame(res)

res$significant <- ifelse(res$padj, "Significant", NA)

ggplot(resDF, aes(baseMean, log2FoldChange, colour=padj))+
  geom_point(size=1)+
  scale_y_continuous(limits=c(-4, 4), oob=squish)+
  scale_x_log10()+
  geom_hline(yintercept = 0, colour="darkorchid4", size=1, linetype="longdash")+
  labs(x="mean of normalized counts", y="log fold change")+
  scale_colour_viridis(direction=-1, trans='sqrt')+
  theme_bw()+
  ggtitle("Maybe scaling padj will show something???")

```



**Volcano Plots**

A volcano plot shows p-value over fold change, so our x axis shows group similarity while y is statistical significance. Ultimately giving us which genes are most down-regulated(left) and up-regulated(right) and their significance. 

_There are two plots because data gets lost on the second plot_ 
```{r,fig.width = 10, fig.height = 10,message=FALSE,warning=FALSE}
library("EnhancedVolcano")
EnhancedVolcano(res,
    lab = symbol_df$geneSymbols,
    x = 'log2FoldChange',
    y = 'pvalue')
```

```{r,fig.width = 20, fig.height = 20,message=FALSE,warning=FALSE}


EnhancedVolcano(res,
    lab = symbol_df$geneSymbols,
    x = "log2FoldChange",
    y = "pvalue",
    pCutoff = 10e-4,
    FCcutoff = 2,
    ylim = c(0, -log10(10e-7)),
    xlim = c(-9,9),
    pointSize = c(ifelse(res$log2FoldChange>2, 8, 1)),
    labSize = 6.0,
    shape = c(6, 6, 19, 16),
    title = "DESeq2 results",
    subtitle = "Differential expression",
    caption = bquote(~Log[2]~ "fold change cutoff, 2; p-value cutoff, 10e-4"),
    legendPosition = "right",
    legendLabSize = 14,
    colAlpha = 0.9,
    colGradient = c('royalblue', 'gold'),
    drawConnectors = TRUE,
    hline = c(10e-8),
    widthConnectors = 0.5)

```




```{r}
table <- subset(symbol_df, select = -c(baseMean,lfcSE,stat,padj),pvalue > 0)
table <- cbind(newColName = rownames(table), table)
rownames(table) <- 1:nrow(table)
names(table)[1] <- 'Gene'

kbl(cbind(table[order(-table$log2FoldChange),][1:10,], 
          table[order(table$log2FoldChange),][1:10,]),
    caption="Top 10 Up/Down-regulated Genes", row.names = FALSE) %>%
  kable_paper() %>%
  add_header_above(c(" " = 1, "Up-regulated Genes" = 3, " " = 1, "Down-regulated Genes" = 3)) 

```


.


## Co-Expression Network

Why Networks? 

1. Gene products don't act indepently in cells 

2. Most tissues are complex hierarchical networks that are spatio-temporally linked through structure and functions.

3. The generation of a network provides insight for understanding predisposition to disease, etiology of organ or behavioral pathology, and response to medications or toxins. 

4. To better understand system level functionality of our genes, modular co-expression provides  information like relevant molecular pathways that relate to phenotype.


The R package cemitools can identify co-expressed gene modules and is meant to be a user-friendly "replacement" to WGCNA. It has the capabilities to perform Over-representation analysis (ORA) and  gene set enrichment analysis (GSEA) as well.

_reference:_ https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2053-1

**Creating a Network** 

To create the network, the correlation values are corrected based on a correction factor. This factor enhances the differences between strong and weak correlations. Weak values become closer to zero. This power value must produce a graph similar to a scale-free network. We can also look at the mean connectivity graphic to help.


```{r,message=FALSE,warning=FALSE,results='hide'}
library("CEMiTool")
#coldata index to colum 
sample_annot <- cbind(SampleName =rownames(coldata), coldata)
rownames(sample_annot) <- 1:nrow(sample_annot)
names(sample_annot)[2] <- "Class"

#Turn array to dataframe 
sample_annot <- as.data.frame(sample_annot)
vassay <- as.data.frame(vassay)

# cemitool
cem <- suppressMessages(cemitool(vassay,sample_annot))
```

Gene Set Enrichment Analysis (GSEA) is a computational method that determines whether a prior defined set of genes shows statistically 
significant, concordant differences between two biological states. Enrichment score (ES) reflects level that genes in a gene set are over represented at the top or bottom of the entire ranked list of genes (NES, Normalized enrichment score). Higher the ES score, it more likely for a gene set to shift towards either end of the ranked list L.

```{r,fig.height=7,warning=FALSE}
# generate heatmap of gene set enrichment analysis
cem <- mod_gsea(cem)
cem <- plot_gsea(cem)
show_plot(cem, "gsea")
```

**Show expression pattern across module** 
```{r,fig.width = 15, fig.height = 8,warning=FALSE}
cem <- plot_profile(cem)
plots <- show_plot(cem, "profile")
plots[1:5]
```

**What genes make up the modules?** 

_The list show genes in the hubs with the (5) highest levels of connectivity._
```{r}
hubs <- get_hubs(cem)
hubs
```



## Citation 

- M. I. Love, W. Huber, S. Anders: Moderated estimation of fold change and dispersion for RNA-Seq data with DESeq2. bioRxiv (2014). doi:10.1101/002832 [1]
 
- Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for sequence count data: removing the noise and preserving large differences. Bioinformatics. 10.1093/bioinformatics/bty895

- Lever, J., Krzywinski, M. & Altman, N. Principal component analysis. Nat Methods 14, 641–642 (2017). https://doi.org/10.1038/nmeth.4346

- Stephens, M. (2016) False discovery rates: a new deal. Biostatistics, 18:2. 10.1093/biostatistics/kxw041

- Lauren Ashlock, Computational Biology Spring 2017, DESeq2 tutorial: https://lashlock.github.io/compbio/R_presentation.html

- https://www.bioconductor.org/packages/release/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html

- https://bioc.ism.ac.jp/packages/2.14/bioc/vignettes/DESeq2/inst/doc/beginner.pdf

- Zhao, Y., Li, MC., Konaté, M.M. et al. TPM, FPKM, or Normalized Counts? A Comparative Study of Quantification Measures for the Analysis of RNA-seq Data from the NCI Patient-Derived Models Repository. J Transl Med 19, 269 (2021). https://doi.org/10.1186/s12967-021-02936-w

- Front. Oncol., 22 April 2021 | https://doi.org/10.3389/fonc.2021.660615

- Russo PST, Ferreira GR, Cardozo LE, Bürger MC, Arias-Carrasco R, Maruyama SR, Hirata TDC, Lima DS, Passos FM, Fukutani KF, Lever M, Silva JS, Maracaja-Coutinho V, Nakaya HI. CEMiTool: a Bioconductor package for performing comprehensive modular co-expression analyses. BMC Bioinformatics. 2018 Feb 20;19(1):56. doi: 10.1186/s12859-018-2053-1. PMID: 29458351; PMCID: PMC5819234.

```{r}
# Print session info
sessioninfo::session_info()
```

